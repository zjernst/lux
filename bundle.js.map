{"version":3,"sources":["webpack:///webpack/bootstrap ec2117dd086a0e205cee","webpack:///./entry.js","webpack:///./gameView.js","webpack:///./game.js","webpack:///./player.js","webpack:///./MovingObject.js","webpack:///./util.js","webpack:///./sight.js","webpack:///./gameOfLife.js","webpack:///./exit.js","webpack:///./ghost.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACzCA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAsC,MAAM;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;;AAEA;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA,kBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;;AAGA;;;;;;;AC1IA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,gCAA+B;AAC/B,QAAO;AACP,gCAA+B;AAC/B;;AAEA,MAAK;;AAEL;AACA,gCAA+B;AAC/B,QAAO;AACP,gCAA+B;AAC/B;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,aAAY;;AAEZ,IAAG;AACH,aAAY;;AAEZ,IAAG;AACH,aAAY;;AAEZ,IAAG;AACH,aAAY;AACZ;AACA;;;AAGA;;;;;;;ACtGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA,kBAAiB,kBAAkB;AACnC,oBAAmB,qBAAqB;AACxC;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClCA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC/BA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,cAAc;AACjC;AACA;AACA,sBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,cAAc;AACjC;AACA,4BAA2B;AAC3B;AACA,sBAAqB,cAAc;AACnC;AACA;AACA;AACA,2DAA0D;AAC1D,2DAA0D;AAC1D,+DAA8D;AAC9D,8DAA6D;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,wBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,oBAAmB,cAAc;AACjC;AACA;AACA,sBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD;AACrD;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC9PA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;ACTA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap ec2117dd086a0e205cee\n **/","const GameView = window.GameView = require('./gameView.js');\nconst GameOfLife = window.GameOfLife = require('./gameOfLife.js');\nconst Util = require('./util');\nconst util = new Util ();\n// const mazeWidth = 482;\n// const mazeHeight = 482;\n\nconst canvasEl = document.getElementById(\"world\");\n\n\ncanvasEl.height = window.innerHeight;\ncanvasEl.width = window.innerWidth;\n\nconst ctx = canvasEl.getContext('2d');\nconst gameView = new GameView(ctx);\n\nconst el = document.getElementsByTagName('body')[0];\nconst infoEl = document.getElementById(\"info\");\n\nkey(\"space\", () => {\n  // debugger\n  if (!gameView.inProgress) {\n    infoEl.className = \"info-wrapper center group gone\"\n\t\tcanvasEl.className = \"visible fade-in\"\n\t\t// newGame.className = \"info gone\"\n\t\t// toolTip.className = \"gone\"\n    gameView.resetScore();\n\t\tgameView.start();\n  }\n})\n// el.addEventListener(\"keydown\", (event) => {\n//   if (event.which === 32 && !gameView.inProgress) {\n//     infoEl.className = \"info-wrapper center group gone\"\n// \t\tcanvasEl.className = \"visible fade-in\"\n// \t\t// newGame.className = \"info gone\"\n// \t\t// toolTip.className = \"gone\"\n//\n// \t\tgameView.start();\n//   }\n// }\n\ngameView.start();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./entry.js\n ** module id = 0\n ** module chunks = 0\n **/","const Game = require('./game.js');\nconst Player = window.Player = require('./player.js');\nconst GameOfLife = require('./gameOfLife.js');\nconst Util = require('./util.js');\nconst util = new Util();\n\nlet score = 0;\n\nfunction GameView(ctx) {\n  this.ctx = ctx;\n}\n\nGameView.prototype.start = function(playerPos) {\n  this.inProgress = true;\n  this.board = this.setBoard();\n  this.game = new Game(this.board, this.start.bind(this), playerPos, score);\n  this.player = this.game.player;\n  score += 1\n\n  this.game.setup(this.ctx);\n  this.keyHandlers();\n\n  requestAnimationFrame(this.animate.bind(this));\n};\n\nGameView.prototype.resetScore = function () {\n  score = 0;\n};\n\nGameView.prototype.setBoard = function (userParams) {\n  const params = {\n    canvas_id:    \"world\",\n    cell_width:   20,\n    cell_height:  20,\n    init_cells:   util.randomStart(window.innerWidth, window.innerHeight, .2),\n    colorful: true\n  }\n  return new GameOfLife(params)\n};\n\nGameView.prototype.animate = function () {\n  this.game.step();\n  this.game.draw(this.ctx);\n  this.isOver();\n\n  requestAnimationFrame(this.animate.bind(this))\n};\n\nGameView.prototype.isOver = function () {\n  let result = this.game.gameOver;\n\n  if (result) {\n    this.inProgress = false;\n    const infoWrapper = document.getElementById(\"info\");\n    const canvas = document.getElementById(\"world\");\n    const loss = document.getElementById(\"lost-game\");\n    const scoreResult = document.getElementById(\"score\");\n\n    infoWrapper.className = \"info-wrapper group center fade-in\"\n    loss.className = \"info fade-in\"\n    scoreResult.innerHTML = `Score: ${score}`\n    canvas.className = \"transparent\"\n  }\n};\n\nGameView.MOVES = {\n  \"w\": [ 0, -.5],\n  \"a\": [-.5,  0],\n  \"s\": [ 0,  .5],\n  \"d\": [ .5,  0],\n  \"up\": [ 0, -.5],\n  \"left\": [-.5,  0],\n  \"right\": [ .5,  0],\n  \"down\": [ 0,  .5]\n};\n\nGameView.prototype.keyHandlers = function() {\n  const player = this.player;\n  Object.keys(GameView.MOVES).forEach((k) => {\n    let move = GameView.MOVES[k];\n    key(k, () => {\n      player.direct(move);\n    })\n  });\n};\n\nmodule.exports = GameView;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./gameView.js\n ** module id = 1\n ** module chunks = 0\n **/","const Player = require('./player.js');\nconst Sight = require('./sight.js');\nconst Exit = require('./exit.js');\nconst Ghost = require('./ghost.js');\nconst Util = require('./util.js');\nconst util = new Util();\n// const GameView = require('./game_view.js');\n\nfunction Game(board, newGame, playerPos, ghosts) {\n  this.newGame = newGame;\n  this.dimY = window.innerHeight;\n  this.dimX = window.innerWidth;\n  this.board = board\n\n  playerPos = playerPos || [(this.dimX / 2), (this.dimY / 2)]\n\n  this.mouse = playerPos;\n  this.player = new Player(playerPos, this);\n  this.ghosts = [];\n  if (ghosts > 0) {\n    for (var i = 0; i < ghosts; i++) {\n      this.ghosts.push(new Ghost (util.randomPos(), this));\n    }\n  }\n  this.allObjects = [this.player].concat(this.ghosts);\n  // this.vision = 300;\n  this.exit = new Exit (this);\n  this.sight = new Sight(this);\n  this.gameOver = false;\n\n};\n\nGame.prototype.setup = function(ctx) {\n  ctx.clearRect(0, 0, this.dimX, this.dimY);\n  this.board.render();\n  this.player.draw(ctx);\n  this.exit.draw(ctx);\n  window.addEventListener('mousemove', (e) => {\n    this.mouse = [e.clientX, e.clientY]\n  });\n  this.boardSetup();\n};\n\nGame.prototype.boardSetup = function() {\n  for (var i = 0; i < 10; i++) {\n    this.board.step();\n  }\n  this.interval = setInterval(() => {\n    this.stepping = true;\n  }, 10000)\n};\n\nGame.prototype.draw = function(ctx) {\n  ctx.clearRect(0, 0, this.dimX, this.dimY);\n  if (this.stepping) {\n    this.board.step();\n    this.stepping = false;\n  } else {\n    this.board.render();\n  }\n\n  if (this.hitWall(ctx, this.player)) {\n    this.player.setMax(.4);\n    console.log(this.player.maxVel);\n  } else {\n    this.player.setMax(2);\n  }\n  this.player.draw(ctx);\n  this.exit.draw(ctx);\n  this.fog(ctx, this.vision);\n  this.sight.draw(ctx);\n  this.ghosts.forEach((ghost) => {\n    ghost.draw(ctx);\n  });\n};\n\nGame.prototype.fog = function (ctx) {\n  let pX = this.player.pos[0];\n  let pY = this.player.pos[1];\n  let gradient = ctx.createRadialGradient(pX, pY, 150, pX, pY, 300);\n  gradient.addColorStop(0, \"rgba(0,0,0,0)\");\n  gradient.addColorStop(1, \"rgba(0,0,0,1)\");\n  ctx.save();\n  ctx.fillStyle = gradient;\n  ctx.fillRect(0,0,this.dimX,this.dimY)\n  ctx.restore();\n};\n\nGame.prototype.moveObjects = function () {\n  this.allObjects.forEach((object) => {\n    object.move();\n  });\n};\n\nGame.prototype.step = function () {\n  this.moveObjects();\n  // this.vision -= .01;\n  this.win();\n  if (this.ghosts.length > 0) {\n    this.over();\n  }\n};\n\nGame.prototype.hitWall = function (ctx, player) {\n  let x = player.pos[0] - player.radius/2;\n  let y = player.pos[1] - player.radius/2;\n  const imgData = ctx.getImageData(x, y, player.radius, player.radius);\n  const pix = imgData.data;\n  for (let i = 0; i < pix.length; i++) {\n    if (pix[i] !== 0) {\n      return true\n    }\n  }\n  return false\n};\n\nGame.prototype.win = function() {\n  if (((this.player.pos[0] > this.exit.pos[0]) &&\n    (this.player.pos[0] < this.exit.pos[0] + 40)) &&\n   ((this.player.pos[1] > this.exit.pos[1]) &&\n    (this.player.pos[1] < this.exit.pos[1] + 40))) {\n      this.player.vel = [0, 0];\n      this.newGame(this.player.pos, 1);\n    }\n};\n\nGame.prototype.over = function() {\n  this.ghosts.forEach((ghost) => {\n    if (((this.player.pos[0] > ghost.pos[0] - ghost.radius) &&\n      (this.player.pos[0] < ghost.pos[0] + ghost.radius)) &&\n     ((this.player.pos[1] > ghost.pos[1] - ghost.radius) &&\n      (this.player.pos[1] < ghost.pos[1] + ghost.radius))) {\n        this.gameOver = true\n      }\n    });\n};\n\n\nmodule.exports = Game;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./game.js\n ** module id = 2\n ** module chunks = 0\n **/","const MovingObject = require('./MovingObject.js');\nconst Util = require('./util.js');\nconst util = new Util();\n\nconst COLOR = \"#3e0013\";\nlet RADIUS = 7.5;\nlet VEL = [0,0];\n\nfunction Player(pos, game) {\n  console.log(VEL)\n  VEL = [0, 0]\n  MovingObject.call(this, pos, VEL, RADIUS, COLOR, game);\n  this.maxVel = 2;\n  this.directing = false\n};\n\nutil.inherits(MovingObject, Player)\n\nPlayer.prototype.direct = function(direction) {\n  this.vel[0] += direction[0];\n  this.vel[1] += direction[1];\n  this.directing = true;\n};\n\nPlayer.prototype.setMax = function (n) {\n  this.maxVel = n;\n};\n\nPlayer.prototype.maxSpeed = function (speed = 2) {\n  if (this.vel[0] > speed) {\n    this.vel[0] = speed\n  }\n  if (this.vel[0] < -speed) {\n    this.vel[0] = -speed\n  }\n  if (this.vel[1] > speed) {\n    this.vel[1] = speed\n  }\n  if (this.vel[1] < -speed) {\n    this.vel[1] = -speed\n  }\n};\n\nPlayer.prototype.decelerate = function () {\n  if (this.vel[0] > 0) {\n    this.vel[0] -= .01\n  } else if (this.vel[0] < 0) {\n    this.vel[0] += .01\n  }\n\n  if (this.vel[1] > 0) {\n    this.vel[1] -= .01\n  } else if (this.vel[1] < 0) {\n    this.vel[1] += .01\n  }\n};\n\nPlayer.prototype.move = function () {\n  this.prevPos = this.pos;\n  this.bounds(this.pos);\n  this.maxSpeed(this.maxVel);\n\n  this.pos[0] = this.pos[0] + this.vel[0];\n  this.pos[1] = this.pos[1] + this.vel[1];\n  if (this.directing === false) {\n    this.decelerate();\n  }\n  this.directing = false;\n};\n\n\n\n\nmodule.exports = Player;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./player.js\n ** module id = 3\n ** module chunks = 0\n **/","function MovingObject(pos, vel, radius, color, game) {\n  this.pos = pos;\n  this.prevPos = pos;\n  this.vel = vel;\n  this.radius = radius;\n  this.color = color;\n  this.game = game;\n}\n\nMovingObject.prototype.draw = function (ctx) {\n  // ctx.clearRect(this.prevPos[0], this.prevPos[1], this.radius * 2, this.radius * 2)\n\n  ctx.fillStyle = this.color;\n  ctx.beginPath();\n\n  ctx.arc(\n    this.pos[0],\n    this.pos[1],\n    this.radius,\n    0,\n    2 * Math.PI,\n    false\n  );\n\n  ctx.fill();\n};\n\nMovingObject.prototype.move = function () {\n  this.prevPos = this.pos;\n  this.bounds(this.pos);\n  console.log(this.maxSpeed);\n  console.log(this.maxSpeed);\n  if (this.constructor === 'Player') {\n    this.decelerate();\n  }\n\n  this.pos[0] = this.pos[0] + this.vel[0];\n  this.pos[1] = this.pos[1] + this.vel[1];\n};\n\nMovingObject.prototype.decelerate = function () {\n  if (this.vel[0] > 0) {\n    this.vel[0] -= .01\n  } else if (this.vel[0] < 0) {\n    this.vel[0] += .01\n  }\n\n  if (this.vel[1] > 0) {\n    this.vel[1] -= .01\n  } else if (this.vel[1] < 0) {\n    this.vel[1] += .01\n  }\n};\n\nMovingObject.prototype.moveBack = function () {\n  this.pos[0] = this.prevPos[0];\n  this.pos[1] = this.prevPos[1];\n  this.vel[0] = 0;\n  this.vel[1] = 0;\n};\n\nMovingObject.prototype.bounds = function(pos) {\n  let checkOutOfBounds = this.checkOutOfBounds(pos);\n\n  if (checkOutOfBounds){\n    if (checkOutOfBounds[\"coord\"] === \"X\"){\n\n      if (checkOutOfBounds[\"low\"]){\n        if (this.vel[0] < 0)  {this.vel[0] *= (-.5)}\n      } else {\n        if (this.vel[0] > 0)  {this.vel[0] *= (-.5)}\n      }\n\n    } else if (checkOutOfBounds[\"coord\"] === \"Y\"){\n\n      if (checkOutOfBounds[\"low\"]){\n        if (this.vel[1] < 0)  {this.vel[1] *= (-.5)}\n      } else {\n        if (this.vel[1] > 0)  {this.vel[1] *= (-.5)}\n      }\n\n    }\n  }\n};\n\nMovingObject.prototype.checkOutOfBounds = function (pos) {\n\n  if ((pos[0]-this.radius) <= 0 ) {\n    return {coord: \"X\", low: true}\n\n  } else if ((pos[0]+this.radius) >= this.game.dimX) {\n    return {coord: \"X\", low: false}\n\n  } else if ((pos[1]-this.radius) <= 0) {\n    return {coord: \"Y\", low: true}\n\n  } else if ((pos[1]+this.radius) >= this.game.dimY) {\n    return {coord: \"Y\", low: false}\n  }\n};\n\n\nmodule.exports = MovingObject;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./MovingObject.js\n ** module id = 4\n ** module chunks = 0\n **/","function Util() {}\n\nUtil.prototype.inherits = function(Parent, Child) {\n  function Surrogate () {}\n\n  Surrogate.prototype = Parent.prototype;\n  Child.prototype = new Surrogate();\n  Child.prototype.constructor = Child;\n};\n\nUtil.prototype.randomPos = function() {\n  const width = window.innerWidth * Math.random();\n  const height = window.innerHeight * Math.random();\n  return [width, height];\n};\n\nUtil.prototype.randomStart = function(windowWidth, windowHeight, weight) {\n  const width = Math.floor(windowWidth/20);\n  const height = Math.floor(windowHeight/20);\n  const board = new Array(height);\n  for (let i = 0; i < board.length; i++) {\n    board[i] = new Array(width);\n  }\n  for (let j = 0; j < board.length; j++) {\n    for (let k = 0; k < board[0].length; k++) {\n      if (Math.random() < weight) {\n        board[j][k] = 1;\n      } else {\n        board[j][k] = 0;\n      }\n    }\n  }\n  return board;\n};\n\nmodule.exports = Util;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./util.js\n ** module id = 5\n ** module chunks = 0\n **/","\nfunction Sight(game) {\n  this.game = game;\n}\n\nSight.prototype.draw = function (ctx) {\n  ctx.fillStyle = 'black';\n  ctx.beginPath();\n  ctx.moveTo(0,0);\n  ctx.lineTo(0, this.game.dimY);\n  ctx.lineTo(this.game.dimX, this.game.dimY);\n  ctx.lineTo(this.game.dimX, 0);\n  ctx.lineTo(0,0);\n\n  let playerX = this.game.player.pos[0];\n  let playerY = this.game.player.pos[1];\n  let mouseX = this.game.mouse[0];\n  let mouseY = this.game.mouse[1];\n\n  ctx.save();\n  ctx.translate(playerX, playerY);\n  let angle = Math.atan2((playerY - mouseY), playerX - mouseX);\n  ctx.rotate(angle + Math.PI/1.33);\n  ctx.moveTo(-20,-20);\n  ctx.lineTo(500, 200);\n  ctx.lineTo(200, 500);\n  ctx.lineTo(-20,-20);\n  ctx.fill();\n  ctx.restore();\n};\n\nmodule.exports = Sight;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./sight.js\n ** module id = 6\n ** module chunks = 0\n **/","/* Author:\n            Matthew Ruten, 2012\n*/\n\nvar GameOfLife = function(params){\n  // User-set params\n  var num_cells_y = params[\"init_cells\"].length,\n      num_cells_x = params[\"init_cells\"][0].length,\n      cell_width  = params[\"cell_width\"]  || 10,\n      cell_height = params[\"cell_height\"] || 10,\n      init_cells  = params[\"init_cells\"]  || [],\n      canvas_id   = params[\"canvas_id\"]   || \"life\",\n\n      colourful   = params[\"colourful\"] || params[\"colorful\"] || false,\n\n      cell_array = [],\n      display     = new GameDisplay(num_cells_x, num_cells_y, cell_width, cell_height, canvas_id, colourful),\n      interval = null,    // Will store reference to setInterval method -- this should maybe be part of GameDisplay\n      init        = function() {\n        // Convert init_cells array of 0's and 1's to actual Cell objects\n        var length_y = init_cells.length,\n            length_x,\n            y, x;\n        // each row\n        for (y = 0; y < length_y; y++) {\n          length_x = init_cells[y].length;\n          // each column in rows\n          for (x = 0; x < length_x; x++) {\n            var state = (init_cells[y][x] == 1) ? 'alive' : 'dead';\n            init_cells[y][x] = new Cell(x, y, state);\n          }\n        }\n        cell_array = init_cells;\n        display.update(cell_array);\n      },\n      // Function to calculate the next generation of cells, based\n      //  on the rules of the Game of Life\n      nextGenCells = function() {\n        // Implement the Game of Life rules\n        // Simple algorithm:\n        //  - For each cell:\n        //      - Check all of its neighbours\n        //      - Based on the rules, set the next gen cell to alive or dead\n\n        var current_gen = cell_array,\n            next_gen = [],      // New array to hold the next gen cells\n            length_y = cell_array.length,\n            length_x,\n            y, x;\n        // each row\n        for (y = 0; y < length_y; y++) {\n          length_x = current_gen[y].length;\n          next_gen[y] = []; // Init new row\n          // each column in rows\n          for (x = 0; x < length_x; x++) {\n            //var state = (init_cells[y][x] == 1) ? 'alive' : 'dead';\n            var cell = current_gen[y][x];\n            // Calculate above/below/left/right row/column values\n            var row_above = (y-1 >= 0) ? y-1 : length_y-1; // If current cell is on first row, cell \"above\" is the last row (stitched)\n            var row_below = (y+1 <= length_y-1) ? y+1 : 0; // If current cell is in last row, then cell \"below\" is the first row\n            var column_left = (x-1 >= 0) ? x-1 : length_x - 1; // If current cell is on first row, then left cell is the last row\n            var column_right = (x+1 <= length_x-1) ? x+1 : 0; // If current cell is on last row, then right cell is in the first row\n\n            var neighbours = {\n              top_left: current_gen[row_above][column_left].clone(),\n              top_center: current_gen[row_above][x].clone(),\n              top_right: current_gen[row_above][column_right].clone(),\n              left: current_gen[y][column_left].clone(),\n              right: current_gen[y][column_right].clone(),\n              bottom_left: current_gen[row_below][column_left].clone(),\n              bottom_center: current_gen[row_below][x].clone(),\n              bottom_right: current_gen[row_below][column_right].clone()\n            };\n\n            var alive_count = 0;\n            var dead_count = 0;\n            for (var neighbour in neighbours) {\n              if (neighbours[neighbour].getState() == \"dead\") {\n                dead_count++;\n              } else {\n                alive_count++;\n              }\n            }\n\n            // Set new state to current state, but it may change below\n            var new_state = cell.getState();\n            if (cell.getState() == \"alive\") {\n              if (alive_count < 2 || alive_count > 3) {\n                // new state: dead, overpopulation/ underpopulation\n                new_state = \"dead\";\n              } else if (alive_count === 2 || alive_count === 3) {\n                // lives on to next generation\n                new_state = \"alive\";\n              }\n            } else {\n              if (alive_count === 3) {\n                // new state: live, reproduction\n                new_state = \"alive\";\n              }\n            }\n\n            //console.log(\"Cell at x,y: \" + x + \",\" + y + \" has dead_count: \" + dead_count + \"and alive_count: \" + alive_count);\n\n            next_gen[y][x] = new Cell(x, y, new_state);\n            //console.log(next_gen[y][x]);\n          }\n        }\n        //console.log(next_gen);\n/*\n        next_gen = cell_array;\n        next_gen[0][0].setState(\"dead\");\n        next_gen[0][1].setState(\"alive\");\n        next_gen[1][0].setState(\"alive\");\n        next_gen[1][1].setState(\"dead\");\n*/\n        return next_gen;\n      }\n  ;\n  init();\n  return {\n    // Returns the next generation array of cells\n    step: function(){\n      var next_gen = nextGenCells();\n      // Set next gen as current cell array\n      cell_array = next_gen;\n      //console.log(next_gen);\n      display.update(cell_array);\n    },\n    // Returns the current generation array of cells\n    getCurrentGenCells: function() {\n      return cell_array;\n    },\n    // Add \"The\" to function name to reduce confusion\n    //  (even though we *could* technically use just setInterval)\n    setTheInterval: function(the_interval) {\n      interval = the_interval;\n    },\n    getInterval: function() {\n      return interval;\n    },\n    render: function() {\n      display.update(this.getCurrentGenCells())\n    }\n  };\n};\n\n// This is an object that will take care of all display-related features.\n// Theoretically, you should be able to use any method of display without\n// too much extra code. i.e. if you want to display the game using HTML tables,\n// svg, or whatever other method you feel like. Just create a new <___>Display\n// Object!\nvar GameDisplay = function(num_cells_x, num_cells_y, cell_width, cell_height, canvas_id, colourful) {\n  var canvas = document.getElementById(canvas_id),\n      ctx = canvas.getContext && canvas.getContext('2d'),\n      width_pixels = num_cells_x * cell_width,\n      height_pixels = num_cells_y * cell_height,\n      drawGridLines = function() {\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = \"rgba(255, 0, 0, 1)\";\n        ctx.beginPath();\n        // foreach column\n        for (var i = 0; i <= num_cells_x; i++) {\n          ctx.moveTo(i*cell_width, 0);\n          ctx.lineTo(i*cell_width, height_pixels);\n        }\n        // foreach row\n        for (var j = 0; j <= num_cells_y; j++) {\n          ctx.moveTo(0, j*cell_height);\n          ctx.lineTo(width_pixels, j*cell_height);\n        }\n        ctx.stroke();\n      },\n      updateCells = function(cell_array) {\n        var length_y = cell_array.length,\n            length_x,\n            y, x;\n        // each row\n        for (y = 0; y < length_y; y++) {\n          length_x = cell_array[y].length;\n          // each column in rows\n          for (x = 0; x < length_x; x++) {\n            // Draw Cell on Canvas\n            drawCell(cell_array[y][x]);\n          }\n        }\n      },\n      drawCell = function(cell) {\n        // find start point (top left)\n        var start_x = cell.getXPos() * cell_width,\n            start_y = cell.getYPos() * cell_height;\n        // draw rect from that point, to bottom right point by adding cell_height/cell_width\n        if (cell.getState() == \"alive\") {\n          //console.log(\"it's alive!\");\n          if (colourful === true) {\n            var r=Math.floor(Math.random()*20),\n                g=Math.floor(Math.random()*40),\n                b=Math.floor(Math.random()*20),\n                a=(Math.floor(Math.random()*3)+9)/10; // rand between 0.5 and 1.0\n            ctx.fillStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",\" + a + \")\";\n          }\n          ctx.fillRect(start_x, start_y, cell_width, cell_height);\n        } else {\n          ctx.clearRect(start_x, start_y, cell_width, cell_height);\n        }\n      },\n      init = function() {\n        //console.log(\"width_pixels: \" + width_pixels);\n        //console.log(\"height_pixels: \" + height_pixels);\n\n        // Resize Canvas\n        canvas.width = width_pixels;\n        canvas.height = height_pixels;\n\n        // No grid lines, for now!\n        //drawGridLines();\n      };\n  init();\n  return {\n    update: function(cell_array) {\n      updateCells(cell_array);\n    }\n  };\n\n\n};\n\nvar Cell = function(x_pos, y_pos, state) {\n  //console.log(\"Creating cell at \" + x_pos + \",\" + y_pos + \", and cell state is: \" + state);\n  /*var x_pos = 0,        // X Position of Cell in Grid\n      y_pos = 0,        // Y position of cell in Grid\n      state = \"dead\",   // Cell state: dead or alive.\n      asdf;*/\n  return {\n    x_pos: x_pos,\n    y_pos: y_pos,\n    state: state,\n    getXPos: function() {\n      return x_pos;\n    },\n    getYPos: function() {\n      return y_pos;\n    },\n    getState: function() {\n      return state;\n    },\n    setState: function(new_state) {\n      state = new_state;\n    },\n    clone: function() {\n      return new Cell(x_pos, y_pos, state);\n    }\n  };\n};\n\nmodule.exports = GameOfLife;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./gameOfLife.js\n ** module id = 7\n ** module chunks = 0\n **/","function Exit(game) {\n  this.pos = [Math.random()*game.dimX, Math.random()*game.dimY]\n}\n\nExit.prototype.draw = function (ctx) {\n  ctx.fillStyle = 'red'\n  ctx.fillRect(this.pos[0], this.pos[1], 40, 40)\n};\n\nmodule.exports = Exit;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./exit.js\n ** module id = 8\n ** module chunks = 0\n **/","const MovingObject = require('./MovingObject.js');\nconst Util = require('./util.js');\nconst util = new Util();\n\nconst COLOR = \"#ccffff\";\nlet RADIUS = 20;\nlet VEL = [0,0];\n\nfunction Ghost(pos, game) {\n  VEL = [0, 0]\n  MovingObject.call(this, pos, VEL, RADIUS, COLOR, game);\n};\n\nutil.inherits(MovingObject, Ghost)\n\nGhost.prototype.findPlayer = function () {\n  return player = this.game.player.pos\n};\n\nGhost.prototype.direct = function() {\n  let player = this.findPlayer();\n  let angle = Math.atan2((player[1] - this.pos[1]), player[0] - this.pos[0]);\n  VEL[0] = Math.cos(angle)/4;\n  VEL[1] = Math.sin(angle)/4;\n};\n\nGhost.prototype.move = function () {\n  this.direct();\n  this.pos[0] = this.pos[0] + VEL[0];\n  this.pos[1] = this.pos[1] + VEL[1];\n};\n\nmodule.exports = Ghost;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./ghost.js\n ** module id = 9\n ** module chunks = 0\n **/"],"sourceRoot":""}